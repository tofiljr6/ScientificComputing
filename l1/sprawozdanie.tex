\documentclass{article}

\usepackage[polish]{babel}
\usepackage[T1]{fontenc}
\usepackage{tabularx}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{graphicx}

\pagestyle{headings}

\begin{document}

\begin{titlepage}
    \title{Obliczenia Naukowe \\ 
    \large lista 1}
    \author{Mateusz Tofil}
    \maketitle
\end{titlepage}

\section{Zadanie 1}

\subsection{Opis zadania}

W tym zadaniu należało wyznaczyć \(macheps\)  czyli najmniejszą liczbę macheps, która spełnia następująca nierówność \( fl(1.0+macheps) > 1.0\). Następnie trzeba było wyznaczyć liczę \(eta\), czyli najmniejszą liczbę większą od 0 tj. \(eta > 0.0\). Kolejnym zadaniem, było wyznaczenie największej liczby \(max\). Każdą z tych liczb (czyli. \emph{macheps, eta, max}) należało wyznaczyć itercyjnie dla wszystkich typów zmiennopozycyjnych.

\subsection{Metoda rozwiązania}

W pliku \texttt{zad1.jl} oraz w \texttt{zad1floath.c} znajdują się programy, z których otrzymałem wyniki przeprowadzonych badań. W każdym z podproblemie zasada działania była bardzo podobna i polegała na dzieleniu lub mnożeniu liczby początkowej, aż do momentu kiedy nie zostało spełnione zdanie logiczne. 

Badałem liczbę \(macheps\) w pętli, aż do momentu kiedy nie zaszedł warunek \(1 + current/2 \neq 1\). W momencie spełnienia warunku, pętla kończyła swoją pracę i zwraca aktualna wartość dla której warunek zachodzi, czyli \(macheps\).

Analogiczny algorytmy wykorzystałem do wyznaczenia liczby \(eta\). W każdej iteracji dzieliłem liczbę do momentu kiedy nie zaszedł warunek \(current/2 \neq 0\).

Licząc liczbę maksymalną zatrzymujemy się po osiągnięciu nieskończoności, która w rzeczywistości została przekroczona. Po wyjściu z pętli należy dodawać do liczby połowy przerwy między nieskończonością. Operacje powtarzać, aż do momentu gdy \(\frac{x}{2^k} \geq1 \) dla pewnego k.

\subsection{Otrzymane wyniki}

W tabelach o numerach 1, 2, 3 zaprezenotwałem zestawienia wyników, które otrzymałem z przeprowadzonych przeze mnie badań. Porównuje je z budowanymi funkcjami w języku Julia, takimi jak np. \(eps()\) czy \(nextfloat()\)) Otrzymane wyniki są zgodnę z wbudowanymi funkcjami, co jednoznacznie stwierdza, że napisane przeze mnie funkcje są poprawnie napisane i zwracają poprawne wyniki.

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|l|}
     \hline
     typ & moja funkcja & funkcja \(eps()\) & float.h \\
     \hline
     Float16 & 0.000977 & 0.000977 & b.d. \\ 
     Float32 & 1.1920929e-7 & 1.1920929e-7 & 1.1920928955e-07 \\
     Float64 & 2.220446049250313e-16 & 2.220446049250313e-16 & 2.2204460493e-16 \\
     \hline
    \end{tabular}
    \caption{Wartości epsilona maszynowego dla typów zmiennopozycyjnych}
    \label{table:1}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
     \hline
     typ & moja funkcja & funkcja \(nextfloat(0.0)\)  \\
     \hline
     Float16 & 6.0e-8 & 6.0e-8 \\ 
     Float32 & 1.0e-45 & 1.0e-45 \\
     Float64 & 5.0e-324 & 5.0e-324 \\
     \hline
    \end{tabular}
    \caption{Wartości \(eta\) dla typów zmiennopozycyjnych}
    \label{table:2}
\end{table}


\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
     \hline
     typ & moja funkcja & funkcja \(nextfloat(0.0)\)  \\
     \hline
     Float16 & 6.55e4 & 6.55e4 \\ 
     Float32 & 3.4028235e38 & 3.4028235e38 \\
     Float64 & 1.7976931348623157e308 & 1.7976931348623157e308 \\
     \hline
    \end{tabular}
    \caption{Wartości max dla typów zmiennopozycyjnych}
    \label{table:3}
\end{table}

\subsubsection{Macheps a precyzja arytmetyki}

Z wykładu wiemy, że  precyzja arytmetyki to \( \frac{1}{2} \beta^{1-t}\). Dla typu pojedycznej prezycji przeznaczone jest 24-bity, natomiast dla podwójnej już 53-bity. Podstawiając, dane to wzoru wyżej, otrzymujemy wyniki, z których widzimy, że prezyja arytmetyki jest dwa razy większa od macheps.

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
     \hline
     typ & precyzja arytmetyki & macheps  \\
     \hline
     Float32 & 5.960464477539063e-8 & 1.1920929e-7 \\
     Float64 & 1.1102230246251565e-16 & 2.220446049250313e-16 \\
     \hline
    \end{tabular}
    \caption{Porównanie prezyzji arytmetyki do macheps}
    \label{table:4}
\end{table}

\subsubsection{\(eta\) a liczba \(MIN_{sub}\)}

Liczba \(eta\) i liczba \(MIN_{sub}\) leżą w tym samym rzędzie, a różnica między nimi jest bardzo mała.

\subsubsection{Związek między \texttt{floatmin()}, a liczbą \(MIN_{nor}\)}

Podobnie jak liczby \(eta\) i \(MIN_{sub}\), wartości zwracane przez funkcje \texttt{floatmin()} leżą w tym samym rzędzie co liczba \(MIN_{nor}\)

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
     \hline
     typ & funkcja \(floatmin()\) & \(MIN_{nor}\)  \\
     \hline
     Float32 & 1.1754944e-38 & 1.2e-38 \\
     Float64 & 2.2250738585072014e-308 & 2.2e-308 \\
     \hline
    \end{tabular}
    \caption{Porównanie wartości floatmin() i \(MIN_{nor}\)}
    \label{table:5}
\end{table}

\subsection{Wnioski}

Liczby w komputerze zgodne ze standardzem IEEE 754 mają skończoną prezcyję, co sprawia że ma skończone zakresy do reprezentacji liczb.

\section{Zadanie 2}

\subsection{Opis zadania}

Zadanie to polegało na sprawdzeniu, czy jesteśmy w stanie obliczając wartość wyrażenia $$\left. 3 * (\frac{4}{3} - 1)-1 \right.$$ otrzymać wartość epsilona maszynowego.

\subsection{Metoda rozwiązania}

Napisałem 3 funkcję, dla każdego typu \texttt{Float16, Float32, Float64}, która obliczała wyżej wymienione wyrażenie.

\subsection{Otrzymane wyniki}

Otrzymane wyniki porównałem z wcześniejszymi wynikami z poprzednich zadań i zestawiłem w tabeli poniżej.

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
     \hline
     typ & wynik wyrażenia & \(eps\)  \\
     \hline
     Float16 & -0.000977 & 0.000977 \\
     Float32 & 1.1920929e-7 & 1.1920929e-7 \\
     Float64 & -2.220446049250313e-16 & 2.220446049250313e-16 \\
     \hline
    \end{tabular}
    \caption{Porównanie wartości z wyrażenia a) z \(eps\)}
    \label{table:6}
\end{table}

Jak widać część naszych wyników pokrywają się. W miejsach gdzie wyniki nie zgadzają się, można zauważyć, są to liczby przeciwne. Najprawdopodobniej spowodowane jest to tym że liczba \(\frac{4}{3}\) w rozwinięciu binarnym ma nieskończone rozwinięcie. Rozwinięcie to prezentuje się następująco \(1.(10)\). Liczba bitów znaczących dla typów danych wynosi:

\begin{itemize}
    \item \texttt{Float16} - 10 bitów
    \item \texttt{Float32} - 23 bity
    \item \texttt{Float64} - 52 bity
\end{itemize}

Więc dla typu Float16 i Float64 ostatnią cyfrą mantysy jest 0, w przeciwieństwie do typu Float32, gdzie ostatnia cyfra mantysy to 1. To właśnie decyduje o znaku odejmowania.

\subsection{Wnioski}

Żyjąc w świecie gdzie istnieje tylko skończona dokłądność reprezentacji, niektóre równania dające w matematyce tożsamości, w arytmetyce zmiennoprzecinkowej mogą dawać zupełnie różne wyniki.



\section{Zadanie 3}

\subsection{Opis problemu}

W tym zadaniu, problem z jakim musiałem się zmierzyć to było zbadanie rozmieszczenia liczb zmiennoprzecinkowych w arytmetyce IEEE 754 o podwójnej prezycji. Rozmieszczenie liczb należało przebadać na różnych przedziałach liczbowych.

\subsection{Metoda rozwiązania}

Program do tego zadania znajduję się w pliku \texttt{zad3.jl}. Do problemu można było podejść w sposób iteracyjny sprawdzjąc czy odstęp między liczbami w przedziale [1,2] wyniosi \(2^{-52}\), natomiast to rozwiązanie jest bardzo długie. Można szybciej, korzystając z wbudowanej funckji \texttt{bitstring} musimy porównań mantysy dwóch liczb podanych na wejściu. Jeżeli mantysy, są równe sobie to na tym przedziale, rozmieszczenie pomiędzy nimi jest równomierne w każdym miejscu. W przeciwnym razie rozmieszczenie jest nierównomierne. Dla arytmetyki \texttt{Float64}, bias to 1023, a mantysa to 52 bity. Zatem aby sprawdzić jak bardzo zmienia się liczba, należy zwrócić uwagę co dzieje się z mantysą, po dodaniu jedynki.

$$\left. 2^{cecha-bias}*2^{-mantysa}\right.$$

\subsection{Otrzymane wyniki}

Liczby w przedziale \([1,2]\) są rozmieszone równomiernie co \(2^{-52}\). Dodatkowo wyznaczyłem odlgełości między liczbami dla innych przedziałów, wyniki zapisałem w tableki poniżej.

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
     \hline
     przedział & odległośći między liczbami  \\
     \hline
     \([0.5, 1]\) & 1.1102230246251565e-16  \\ 
     \([1, 2]\) & 2.220446049250313e-16  \\
     \([2,4]\) & 4.440892098500626e-16  \\
     \hline
    \end{tabular}
    \caption{Przedziały i odległości między liczbami w danym przedziale}
    \label{table:7}
\end{table}

\subsection{Wnisoki}

Liczby w IEEE 754 są reprezntoane z określoną dokładnością różniącą się zależnie od przedziału, w którym się znajdują, przedziały bliżej zera są bardziej gęstrze niż przedziały oddalone dalej.

\section{Zadanie 4}

\subsection{Opis problemu}

Problem, jaki znajdował się w tym zadaniu to było znalezienie dwóch liczb zmiennoprzecinkowych. Pierwsza liczba to była liczba \(x\) leżąca w przedziale \(1 < x < 2\), taka, że spełnia nierówność: $$\left.  x * \frac{1}{x} \neq 1\right.$$ Druga część opierała się na podobnnym zadaniu, tylko tym razem należało znaleźć najmniejszą taką liczbę, która spełnia powyższą nierówność.

\subsection{Metoda rozwiązania}

Rozwiązania znajdują sie w pliku \texttt{zad4.jl}. Metodologia polega na zaczęciu od liczby, która jest dolnym ograniczeniem powyższych nierówności i powiększaniu jej do momentu gdy nierówność nie będzie prawdziwa. Podpunkt ten rozbiłem na dwa mnijesze jeszcze podpunkty, ze względu na najmniejszą liczbę dodatnią (b1), czy najmniejszą liczbę w ogólności. (b2)

\subsection{Otrzymane wyniki}

Napisane przez mnie algorytmy, zwróciły następujące wyniki:

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
     \hline
     podpunktu & szukany x & wartość wyrażenia x * (1/x) \\
     \hline
     \(a\) & 1.000000057228997 & 0.9999999999999999  \\ 
     \(b1\) & 1.0e-323 & inf \\ 
     \(b2\) & -1.0e-323 & inf \\ 
     \hline
    \end{tabular}
    \caption{Szukane wartości x i wartości wyrażenia}
    \label{table:8}
\end{table}

\subsection{Wnioski}

Liczby reprezentowane w komputerze mają skończoną prezycję i chcąc policzyć nawet bardzo łatwe (nie)równości z matematyki, komputer ma problemy z poprawnym obliczaniem. Podpunkt b dał zaskakujące wyniki, mianowicie najmniejsza liczba dodatnia i najmnijesza liczba w ogólności są równe co do wartości bezwzględnej.

\section{Zadanie 5}

\subsection{Opis problemu}

Zadanie 5 polega na  eksperymentalnym obliczeniu iloczynów skalarnych dwóch wektorów, które na wejściu są już podane. Eksperymenty należało przeprowadzić na 4 różnych algorytmach liczenia iloczy skalarnego:

\begin{enumerate}[label=(\alph*)]
    \item liczenie w przód, zaczynając od początku tablicy
    \item liczenie w tył, zaczynając od końca tablicy
    \item liczenie od największego iloczynu do najmniejszego
    \item liczenie od najmniejszego iloczyny do największego
\end{enumerate}

\subsection{Metoda rozwiązania}

Zaimplementowane algorytmy znajdują się w pliku \texttt{zad5.jl}. Reprezentują wcześniej metody rozwiązane w języku Julia.

\subsection{Otrzymane wyniki}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
     \hline
     podpunkt & suma \\
     \hline
     \(a\) & 1.0251881368296672e-10  \\ 
     \(b\) & -1.5643308870494366e-10 \\
     \(c\) & 0.0 \\
     \(d\) & 0.0 \\
     \hline
    \end{tabular}
    \caption{Wyniki dla \texttt{Float64}}
    \label{table:9}
\end{table}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
     \hline
     podpunkt & suma \\
     \hline
     \(a\) & -0.3472038161853561  \\ 
     \(b\) & -0.3472038162872195 \\
     \(c\) & -0.5 \\
     \(d\) & -0.5 \\
     \hline
    \end{tabular}
    \caption{Wyniki dla \texttt{Float32}}
    \label{table:10}
\end{table}

\subsection{Wnioski}

Z punkty widzenia matematyki, wykonywanie tych algorytmów powinno dać równe wyniki, bez względu na kolejność wykonywania działać. (Zachowując reguły kolejnośći wykonywania działań). Natomisat w komputerze, kolejność wykonywanych działań może zmienić się w zależności od wykonywanych działań.

\section{Zadanie 6}

\subsection{Opis problemu}

W tym zadaniu należało obliczyć wartości dwóch równoważnych funkcji (pod względem matematycznym) dla argumentów \(8^{-1}\), \(8^{-2}\), \(8^{-3}\)... \(8^{-k}\) \(k \in \mathbb{N}\). Równoważne funckje to:

\begin{multline}
    g(x) = \frac{x^2}{\sqrt{x^2 + 1} + 1}  = \frac{x^2 \cdot (\sqrt{x^2 +1 } - 1)}{(\sqrt{x^2+1} + 1)\cdot(\sqrt{x^2+1} - 1)}  =  \\  = \frac{x^2 \cdot (\sqrt{x^2 +1 } - 1)}{(\sqrt{x^2+1} + 1)\cdot(\sqrt{x^2+1} - 1)} = \frac{x^2 \cdot (\sqrt{x^2+1}-1)}{x^2 + 1 - 1} = \sqrt{x^2+1} - 1 = f(x)
\end{multline}

\subsection{Metoda rozwiązania}

Zaimplementowane algorytmy znajdują się w pliku \texttt{zad6.jl}. Reprezentują wcześniej metody rozwiązane w języku Julia.

\subsection{Otrzymane wyniki}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|}
    \hline
    k  & \(f(8^{-k})\) & \(g(8^{-k})\) \\
    \hline
    1&0.0077822185373186414&0.0077822185373187065\\
    2&0.00012206286282867573&0.00012206286282875901\\
    3&1.9073468138230965e-6&1.907346813826566e-6\\
    4&2.9802321943606103e-8&2.9802321943606116e-8\\
    5&4.656612873077393e-10&4.6566128719931904e-10\\
    6&7.275957614183426e-12&7.275957614156956e-12\\
    7&1.1368683772161603e-13&1.1368683772160957e-13\\
    8&1.7763568394002505e-15&1.7763568394002489e-15\\
    9&0.0&2.7755575615628914e-17\\
    10&0.0&4.336808689942018e-19\\
    10&0.0&4.336808689942018e-19\\
    20&0.0&3.76158192263132e-37\\
    30&0.0&3.2626522339992623e-55\\
    40&0.0&2.8298997121333476e-73\\
    50&0.0&2.4545467326488633e-91\\
    60&0.0&2.1289799200040754e-109\\
    70&0.0&1.8465957235571472e-127\\
    80&0.0&1.6016664761464807e-145\\
    90&0.0&1.3892242184281734e-163\\
    100&0.0&1.204959932551442e-181\\
    110&0.0&1.0451361413042083e-199\\
    120&0.0&9.065110999561118e-218\\
    130&0.0&7.862730431637126e-236\\
    140&0.0&6.819831532519088e-254\\
    150&0.0&5.915260930833874e-272\\
    160&0.0&5.1306710016229703e-290\\
    170&0.0&4.450147717014403e-308\\
    180&0.0&0.0\\
    190&0.0&0.0\\
    200&0.0&0.0\\
     \hline
    \end{tabular}
    \caption{Porównanie wartości funkcji f i g z zadania 6}
    \label{table:11}
\end{table}

Jak łatwo zauważyć, funckja \(f(x)\) szybko osiąga wartości równe 0.0, gdy funckja \(g(x)\) wciąż liczy dla mniejszych argumentów wartości funkcji. Funkcja \(g(x)\) jest 10-razy efektywniejsza niż funkcja \(f(x)\).

\subsection{Wnioski}

Podobnie jak w zadaniu poprzednim, mimo że dwie funkcje, \(f(x)\) i \(g(x)\) matematycznie są równoważne, komputer zwraca prawidłowe wyniki tylko do pewnego momentu, a w ostateczności zwraca niepoprawne.

\section{Zadanie 7}

\subsection{Opis problemu}

W tym zadaniu należało wyliczyć wartość pochodnej \(f(x)\) za pomocą wzoru

$$\left. f'(x_{0}) \approx \frac{f(x_{0} + h) - f(x_{0})}{h}, h \rightarrow 0\right.$$

i porównać ją z wartością matematycznej pochodnej funckji w punkcie \(x_{0}\)

$$f(x) = sin(x) + cos(3x)$$
$$f'(x) = cos(x) - 3cos(3x)$$

\subsection{Metoda rozwiązania}

Zaimplementowane algorytmy znajdują się w pliku \texttt{zad7.jl}. Reprezentują wcześniejsze implementacje równań.

\subsection{Otrzymane wyniki}

Wartość pochodnej w punkcie x + 0 = 1 to 0.11694228168853815. Z otrzymanych wyników możemy wywnioskować, że najlepsze przybliżenie wartośći pochodnej w tym punkcie jest dla \(h=2^{-28}\), gdzie bład jest najmniejszy. Po tej wartości bład rośnie, a dla \(h=2^{-54}\) wynosi już prawie \(0.117\).

\begin{table}[h!]
    \centering
    \begin{tabular}{|l|l|l|l|}
    \hline
    h  & h+1 & \( \widetilde{f'}(x_{0})\) & \( |f'(x_{0}) - \widetilde{f'}(x_{0}) | \) \\
    \hline
    \(2^{-0}\)&2.0&2.0179892252685967&1.9010469435800585\\
    \(2^{-1}\)&1.5&1.8704413979316472&1.753499116243109\\
    \(2^{-2}\)&1.25&1.1077870952342974&0.9908448135457593\\
    \(2^{-3}\)&1.125&0.6232412792975817&0.5062989976090435\\
    \(2^{-4}\)&1.0625&0.3704000662035192&0.253457784514981\\
    \(2^{-5}\)&1.03125&0.24344307439754687&0.1265007927090087\\
    % \(2^{-6}\)&1.015625&0.18009756330732785&0.0631552816187897\\
    % \(2^{-7}\)&1.0078125&0.1484913953710958&0.03154911368255764\\
    % \(2^{-8}\)&1.00390625&0.1327091142805159&0.015766832591977753\\
    % \(2^{-9}\)&1.001953125&0.1248236929407085&0.007881411252170345\\
    % \(2^{-10}\)&1.0009765625&0.12088247681106168&0.0039401951225235265\\
    % \(2^{-11}\)&1.00048828125&0.11891225046883847&0.001969968780300313\\
    % \(2^{-12}\)&1.000244140625&0.11792723373901026&0.0009849520504721099\\
    % \(2^{-13}\)&1.0001220703125&0.11743474961076572&0.0004924679222275685\\
    % \(2^{-14}\)&1.00006103515625&0.11718851362093119&0.0002462319323930373\\
    % \(2^{-15}\)&1.000030517578125&0.11706539714577957&0.00012311545724141837\\
    % \(2^{-16}\)&1.0000152587890625&0.11700383928837255&6.155759983439424e-5\\
    % \(2^{-17}\)&1.0000076293945312&0.11697306045971345&3.077877117529937e-5\\
    % \(2^{-18}\)&1.0000038146972656&0.11695767106721178&1.5389378673624776e-5\\
    % \(2^{-19}\)&1.0000019073486328&0.11694997636368498&7.694675146829866e-6\\
    % \(2^{-20}\)&1.0000009536743164&0.11694612901192158&3.8473233834324105e-6\\
    % \(2^{-21}\)&1.0000004768371582&0.1169442052487284&1.9235601902423127e-6\\
    \hline
    \vdots & \vdots & \vdots & \vdots \\
    \hline
    \(2^{-22}\)&1.000000238418579&0.11694324295967817&9.612711400208696e-7\\
    \(2^{-23}\)&1.0000001192092896&0.11694276239722967&4.807086915192826e-7\\
    \(2^{-24}\)&1.0000000596046448&0.11694252118468285&2.394961446938737e-7\\
    \(2^{-25}\)&1.0000000298023224&0.116942398250103&1.1656156484463054e-7\\
    \(2^{-26}\)&1.0000000149011612&0.11694233864545822&5.6956920069239914e-8\\
    \(2^{-27}\)&1.0000000074505806&0.11694231629371643&3.460517827846843e-8\\
    \(2^{-28}\)&1.0000000037252903&0.11694228649139404&4.802855890773117e-9\\
    \(2^{-29}\)&1.0000000018626451&0.11694222688674927&5.480178888461751e-8\\
    \(2^{-30}\)&1.0000000009313226&0.11694216728210449&1.1440643366000813e-7\\
    \(2^{-31}\)&1.0000000004656613&0.11694216728210449&1.1440643366000813e-7\\
    \(2^{-32}\)&1.0000000002328306&0.11694192886352539&3.5282501276157063e-7\\
    \(2^{-33}\)&1.0000000001164153&0.11694145202636719&8.296621709646956e-7\\
    \(2^{-34}\)&1.0000000000582077&0.11694145202636719&8.296621709646956e-7\\
    \(2^{-35}\)&1.0000000000291038&0.11693954467773438&2.7370108037771956e-6\\
    \hline
    \vdots & \vdots & \vdots & \vdots \\
    \hline
    % \(2^{-36}\)&1.000000000014552&0.116943359375&1.0776864618478044e-6\\
    % \(2^{-37}\)&1.000000000007276&0.1169281005859375&1.4181102600652196e-5\\
    % \(2^{-38}\)&1.000000000003638&0.116943359375&1.0776864618478044e-6\\
    % \(2^{-39}\)&1.000000000001819&0.11688232421875&5.9957469788152196e-5\\
    % \(2^{-40}\)&1.0000000000009095&0.1168212890625&0.0001209926260381522\\
    % \(2^{-41}\)&1.0000000000004547&0.116943359375&1.0776864618478044e-6\\
    % \(2^{-42}\)&1.0000000000002274&0.11669921875&0.0002430629385381522\\
    % \(2^{-43}\)&1.0000000000001137&0.1162109375&0.0007313441885381522\\
    % \(2^{-44}\)&1.0000000000000568&0.1171875&0.0002452183114618478\\
    % \(2^{-45}\)&1.0000000000000284&0.11328125&0.003661031688538152\\
    % \(2^{-46}\)&1.0000000000000142&0.109375&0.007567281688538152\\
    % \(2^{-47}\)&1.000000000000007&0.109375&0.007567281688538152\\
    % \(2^{-48}\)&1.0000000000000036&0.09375&0.023192281688538152\\
    \(2^{-49}\)&1.0000000000000018&0.125&0.008057718311461848\\
    \(2^{-50}\)&1.0000000000000009&0.0&0.11694228168853815\\
    \(2^{-51}\)&1.0000000000000004&0.0&0.11694228168853815\\
    \(2^{-52}\)&1.0000000000000002&-0.5&0.6169422816885382\\
    \(2^{-53}\)&1.0&0.0&0.11694228168853815\\
    \(2^{-54}\)&1.0&0.0&0.11694228168853815\\
    \hline
    \end{tabular}
    \caption{Przybliżone wartości pochodnej}
    \label{table:12}
\end{table}

\begin{figure}
    \centering
    \includegraphics[width=12cm]{./charts/wykres.png}
    \caption{Wykres}
\end{figure}

\subsection{Wnioski}

Liczby zmiennoprzecinkowe bliskie zeru posiadają niewielką liczbę cyfr znaczących w swoim zapisie. Z każdą iteracją, tracona jest dokładność obliczeń, aż do momentu w którym je odrzucamy. Zatem należy uważać, pracując na liczbach bliskim zeru.

\end{document}